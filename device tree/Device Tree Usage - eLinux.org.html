<!DOCTYPE html>
<html class="client-js" dir="ltr" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>Device Tree Usage - eLinux.org</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Device_Tree_Usage","wgTitle":"Device Tree Usage","wgCurRevisionId":503926,"wgRevisionId":503926,"wgArticleId":106826,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Device tree"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Device_Tree_Usage","wgRelevantArticleId":106826,"wgRequestId":"598beae2aa375da0f58668ba","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","site":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@0qsj60i",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["ext.cite.a11y","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="Device%20Tree%20Usage%20-%20eLinux.org_files/load_002.css">
<script async="" src="Device%20Tree%20Usage%20-%20eLinux.org_files/load_002.php"></script>
<style>
.cite-accessibility-label{ top:-99999px;clip:rect(1px 1px 1px 1px); clip:rect(1px,1px,1px,1px); position:absolute !important;padding:0 !important;border:0 !important;height:1px !important;width:1px !important; overflow:hidden}
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:0;z-index:1099;padding:0;margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:#fff;cursor:pointer;border:1px solid #a2a9b1;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:#fff;cursor:pointer;border:1px solid #a2a9b1;padding:0;margin:0}.suggestions-result{color:#000;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#2a4b8d;color:#fff}.suggestions-special .special-label{color:#72777d;text-align:left}.suggestions-special .special-query{color:#000;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:#c8ccd1}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:#fff}.highlight{font-weight:bold}
@media screen {
	.tochidden,.toctoggle{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.toctoggle{font-size:94%}}
@media print {
	.toc.tochidden,.toctoggle{display:none}}</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:#000;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:#fff}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;text-overflow:ellipsis;white-space:nowrap}</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="Device%20Tree%20Usage%20-%20eLinux.org_files/load.css">
<meta name="generator" content="MediaWiki 1.31.0">
<link rel="shortcut icon" href="https://elinux.org/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="https://elinux.org/opensearch_desc.php" title="eLinux.org (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://elinux.org/api.php?action=rsd">
<link rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">
<link rel="alternate" type="application/atom+xml" title="eLinux.org Atom feed" href="https://elinux.org/index.php?title=Special:RecentChanges&amp;feed=atom">
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1"></script><![endif]-->
<script src="Device%20Tree%20Usage%20-%20eLinux.org_files/load.php"></script></head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Device_Tree_Usage rootpage-Device_Tree_Usage skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><script>document.write("\u003Cdiv id=\"localNotice\" lang=\"en\" dir=\"ltr\"\u003E\u003Cp\u003E\u003Cbr /\u003E\n\u003C/p\u003E\u003Cp\u003E\u003Cbr /\u003E\n\u003C/p\u003E\u003C/div\u003E");</script><div id="localNotice" dir="ltr" lang="en"><p><br>
</p><p><br>
</p></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Device Tree Usage</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From eLinux.org</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="en"><div class="mw-parser-output"><p><br>
<a href="https://elinux.org/Device_Tree" class="mw-redirect" title="Device Tree"> Top Device Tree page</a>
</p><p><br>
(This page was previously located at htttp://devicetree.org/Device_Tree_Usage)
</p><p>This page walks through how to write a device tree for a new 
machine.  It is intended to provide an overview of device tree concepts 
and how they are used to describe a machine.
</p><p>For a full technical description of device tree data format, refer to the
<a rel="nofollow" class="external text" href="https://www.power.org/documentation/power-org-standard-for-embedded-power-architecture-platform-requirements-epapr-v1-1-2/">ePAPR v1.1</a>
 specification.  The ePAPR specification covers a lot more detail than 
the basic topics covered on this page, please refer to it for more 
advanced usage that isn't covered by this page.
<a href="https://elinux.org/Device_tree_future#Devicetree_Specification" title="Device tree future"> The ePAPR is currently being updated</a> with a new
name of Devicetree Specification Documentation.
</p>
<div id="toc" class="toc"><div class="toctitle" dir="ltr" lang="en"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a role="button" tabindex="0" class="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Basic_Data_Format"><span class="tocnumber">1</span> <span class="toctext">Basic Data Format</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Basic_Concepts"><span class="tocnumber">2</span> <span class="toctext">Basic Concepts</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Sample_Machine"><span class="tocnumber">2.1</span> <span class="toctext">Sample Machine</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Initial_structure"><span class="tocnumber">2.2</span> <span class="toctext">Initial structure</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#CPUs"><span class="tocnumber">2.3</span> <span class="toctext">CPUs</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Node_Names"><span class="tocnumber">2.4</span> <span class="toctext">Node Names</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Devices"><span class="tocnumber">2.5</span> <span class="toctext">Devices</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Understanding_the_compatible_Property"><span class="tocnumber">2.6</span> <span class="toctext">Understanding the compatible Property</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#How_Addressing_Works"><span class="tocnumber">3</span> <span class="toctext">How Addressing Works</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#CPU_addressing"><span class="tocnumber">3.1</span> <span class="toctext">CPU addressing</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Memory_Mapped_Devices"><span class="tocnumber">3.2</span> <span class="toctext">Memory Mapped Devices</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Non_Memory_Mapped_Devices"><span class="tocnumber">3.3</span> <span class="toctext">Non Memory Mapped Devices</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Ranges_.28Address_Translation.29"><span class="tocnumber">3.4</span> <span class="toctext">Ranges (Address Translation)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#How_Interrupts_Work"><span class="tocnumber">4</span> <span class="toctext">How Interrupts Work</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Device_Specific_Data"><span class="tocnumber">5</span> <span class="toctext">Device Specific Data</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Special_Nodes"><span class="tocnumber">6</span> <span class="toctext">Special Nodes</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#aliases_Node"><span class="tocnumber">6.1</span> <span class="toctext">aliases Node</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#chosen_Node"><span class="tocnumber">6.2</span> <span class="toctext">chosen Node</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Advanced_Topics"><span class="tocnumber">7</span> <span class="toctext">Advanced Topics</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#Advanced_Sample_Machine"><span class="tocnumber">7.1</span> <span class="toctext">Advanced Sample Machine</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#PCI_Host_Bridge"><span class="tocnumber">7.2</span> <span class="toctext">PCI Host Bridge</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#PCI_Bus_numbering"><span class="tocnumber">7.2.1</span> <span class="toctext">PCI Bus numbering</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#PCI_Address_Translation"><span class="tocnumber">7.2.2</span> <span class="toctext">PCI Address Translation</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#PCI_DMA_Address_Translation"><span class="tocnumber">7.2.3</span> <span class="toctext">PCI DMA Address Translation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25"><a href="#Advanced_Interrupt_Mapping"><span class="tocnumber">7.3</span> <span class="toctext">Advanced Interrupt Mapping</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="#Notes"><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Basic_Data_Format">Basic Data Format</span></h2>
<p>The device tree is a simple tree structure of nodes and properties.  
Properties are key-value pairs, and node may contain both properties and
 child nodes.  For example, the following is a simple tree in the <a href="https://elinux.org/index.php?title=Definitions&amp;action=edit&amp;redlink=1" class="new" title="Definitions (page does not exist)"> .dts</a> format:
</p>
<pre>/dts-v1/;

/ {
    node1 {
        a-string-property = "A string";
        a-string-list-property = "first string", "second string";
        // hex is implied in byte arrays. no '0x' prefix is required
        a-byte-data-property = [01 23 34 56];
        child-node1 {
            first-child-property;
            second-child-property = &lt;1&gt;;
            a-string-property = "Hello, world";
        };
        child-node2 {
        };
    };
    node2 {
        an-empty-property;
        a-cell-property = &lt;1 2 3 4&gt;; /* each number (cell) is a uint32 */
        child-node1 {
        };
    };
};
</pre>
<p>This tree is obviously pretty useless because it doesn't describe 
anything, but it does show the structure of nodes and properties.  There
 is:
</p>
<ul><li>a single root node: "<code>/</code>"</li>
<li>a couple of child nodes: "<code>node1</code>" and "<code>node2</code>"</li>
<li>a couple of children for node1: "<code>child-node1</code>" and "<code>child-node2</code>"</li>
<li>a bunch of properties scattered through the tree.</li></ul>
<p>Properties are simple key-value pairs where the value can either be 
empty or contain an arbitrary byte stream.  While data types are not 
encoded into the data structure, there are a few fundamental data 
representations that can be expressed in a device tree source file.
</p>
<ul><li>Text strings (null terminated) are represented with double quotes:
<ul><li><code>string-property = "a string";</code></li></ul></li>
<li>'Cells' are 32 bit unsigned integers delimited by angle brackets:
<ul><li><code>cell-property = &lt;0xbeef 123 0xabcd1234&gt;;</code></li></ul></li>
<li>Binary data is delimited with square brackets:
<ul><li><code>binary-property = [0x01 0x23 0x45 0x67];</code></li></ul></li>
<li>Data of differing representations can be concatenated together using a comma:
<ul><li><code>mixed-property = "a string", [0x01 0x23 0x45 0x67], &lt;0x12345678&gt;;</code></li></ul></li>
<li>Commas are also used to create lists of strings:
<ul><li><code>string-list = "red fish", "blue fish";</code></li></ul></li></ul>
<h2><span class="mw-headline" id="Basic_Concepts">Basic Concepts</span></h2>
<p>To understand how the device tree is used, we will start with a 
simple machine and build up a device tree to describe it step by step.
</p>
<h3><span class="mw-headline" id="Sample_Machine">Sample Machine</span></h3>
<p>Consider the following imaginary machine (loosely based on ARM Versatile), manufactured by "Acme" and named "Coyote's Revenge":
</p>
<ul><li>One 32bit ARM CPU</li>
<li>processor local bus attached to memory mapped serial port, spi bus 
controller, i2c controller, interrupt controller, and external bus 
bridge</li>
<li>256MB of SDRAM based at 0</li>
<li>2 Serial ports based at 0x101F1000 and 0x101F2000</li>
<li>GPIO controller based at 0x101F3000</li>
<li>SPI controller based at 0x10170000 with following devices
<ul><li>MMC slot with SS pin attached to GPIO #1</li></ul></li>
<li>External bus bridge with following devices
<ul><li>SMC SMC91111 Ethernet device attached to external bus based at 0x10100000</li>
<li>i2c controller based at 0x10160000 with following devices
<ul><li>Maxim DS1338 real time clock.  Responds to slave address 1101000 (0x58)</li></ul></li>
<li>64MB of NOR flash based at 0x30000000</li></ul></li></ul>
<h3><span class="mw-headline" id="Initial_structure">Initial structure</span></h3>
<p>The first step is to lay down a skeleton structure for the machine.  
This is the bare minimum structure required for a valid device tree.  At
 this stage you want to uniquely identify the machine.
</p>
<pre>/dts-v1/;

/ {
    <b>compatible = "acme,coyotes-revenge";</b>
};
</pre>
<p><code>compatible</code> specifies the name of the system.  It 
contains a string in the form "&lt;manufacturer&gt;,&lt;model&gt;.  It 
is important to specify the exact device, and to include the 
manufacturer name to avoid namespace collisions.  Since the operating 
system will use the <code>compatible</code> value to make decisions about how to run on the machine, it is very important to put correct data into this property.
</p><p>Theoretically, compatible is all the data an OS needs to uniquely
 identify a machine.  If all the machine details are hard coded, then 
the OS could look specifically for "acme,coyotes-revenge" in the top 
level <code>compatible</code> property.
</p>
<h3><span class="mw-headline" id="CPUs">CPUs</span></h3>
<p>Next step is to describe for each of the CPUs.  A container node 
named "cpus" is added with a child node for each CPU.  In this case the 
system is a dual-core Cortex A9 system from ARM.
</p>
<pre>/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";

    <b>cpus {
        cpu@0 {
            compatible = "arm,cortex-a9";
        };
        cpu@1 {
            compatible = "arm,cortex-a9";
        };
    };</b>
};
</pre>
<p>The compatible property in each cpu node is a string that specifies the exact cpu model in the form <code>&lt;manufacturer&gt;,&lt;model&gt;</code>, just like the compatible property at the top level.
</p><p>More properties will be added to the cpu nodes later, but we first need to talk about more of the basic concepts.
</p>
<h3><span class="mw-headline" id="Node_Names">Node Names</span></h3>
<p>It is worth taking a moment to talk about naming conventions.  Every node must have a name in the form <code>&lt;name&gt;[@&lt;unit-address&gt;</code>].
</p><p><code>&lt;name&gt;</code> is a simple ascii string and can be up 
to 31 characters in length.  In general, nodes are named according to 
what kind of device it represents.  ie. A node for a 3com Ethernet 
adapter would be use the name <code>ethernet</code>, not <code>3com509</code>.
</p><p>The unit-address is included if the node describes a device with 
an address.  In general, the unit address is the primary address used to
 access the device, and is listed in the node's <code>reg</code> property.  We'll cover the reg property later in this document.
</p><p>Sibling nodes must be uniquely named, but it is normal for more 
than one node to use the same generic name so long as the address is 
different (ie, serial@101f1000 &amp; serial@101f2000).
</p><p>See section 2.2.1 of the ePAPR spec for full details about node naming.
</p>
<h3><span class="mw-headline" id="Devices">Devices</span></h3>
<p>Every device in the system is represented by a device tree node.  The
 next step is to populate the tree with a node for each of the devices. 
 For now, the new nodes will be left empty until we can talk about how 
address ranges and irqs are handled.
</p>
<pre>/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";

    cpus {
        cpu@0 {
            compatible = "arm,cortex-a9";
        };
        cpu@1 {
            compatible = "arm,cortex-a9";
        };
    };

    <b>serial@101F0000 {
        compatible = "arm,pl011";
    };

    serial@101F2000 {
        compatible = "arm,pl011";
    };

    gpio@101F3000 {
        compatible = "arm,pl061";
    };

    interrupt-controller@10140000 {
        compatible = "arm,pl190";
    };

    spi@10115000 {
        compatible = "arm,pl022";
    };

    external-bus {
        ethernet@0,0 {
            compatible = "smc,smc91c111";
        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            rtc@58 {
                compatible = "maxim,ds1338";
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
        };
    };</b>
};
</pre>
<p>In this tree, a node has been added for each device in the system, 
and the hierarchy reflects the how devices are connected to the system. 
 ie. devices on the extern bus are children of the external bus node, 
and i2c devices are children of the i2c bus controller node.  In 
general, the hierarchy represents the view of the system from the 
perspective of the CPU.
</p><p>This tree isn't valid at this point.  It is missing information 
about connections between devices.  That data will be added later.
</p><p>Some things to notice in this tree:
</p>
<ul><li>Every device node has a <code>compatible</code> property.</li>
<li>The flash node has 2 strings in the compatible property.  Read on to the next section to learn why.</li>
<li>As mentioned earlier, node names reflect the type of device, not the
 particular model.  See section 2.2.2 of the ePAPR spec for a list of 
defined generic node names that should be used wherever possible.</li></ul>
<h3><span class="mw-headline" id="Understanding_the_compatible_Property">Understanding the <code>compatible</code> Property</span></h3>
<p>Every node in the tree that represents a device is required to have the <code>compatible</code> property.  <code>compatible</code> is the key an operating system uses to decide which device driver to bind to a device.
</p><p><code>compatible</code> is a list of strings.  The first string in the list specifies the exact device that the node represents in the form <code>"&lt;manufacturer&gt;,&lt;model&gt;"</code>.  The following strings represent other devices that the device is <i>compatible</i> with.
</p><p>For example, the Freescale MPC8349 System on Chip (SoC) has a 
serial device which implements the National Semiconductor ns16550 
register interface.  The compatible property for the MPC8349 serial 
device should therefore be: <code>compatible = "fsl,mpc8349-uart", "ns16550"</code>.  In this case, <code>fsl,mpc8349-uart</code> specifies the exact device, and <code>ns16550</code> states that it is register-level compatible with a National Semiconductor 16550 UART.
</p><p>Note: <code>ns16550</code> doesn't have a manufacturer prefix 
purely for historical reasons.  All new compatible values should use the
 manufacturer prefix.
</p><p>This practice allows existing device drivers to be bound to a newer device, while still uniquely identifying the exact hardware.
</p><p>Warning: Don't use <i>wildcard</i> compatible values, like 
"fsl,mpc83xx-uart" or similar.  Silicon vendors will invariably make a 
change that breaks your wildcard assumptions the moment it is too late 
to change it.  Instead, choose a specific silicon implementations and 
make all subsequent silicon <i>compatible</i> with it.
</p>
<h2><span class="mw-headline" id="How_Addressing_Works">How Addressing Works</span></h2>
<p>Devices that are addressable use the following properties to encode address information into the device tree:
</p>
<ul><li><code>reg</code></li>
<li><code>#address-cells</code></li>
<li><code>#size-cells</code></li></ul>
<p>Each addressable device gets a <code>reg</code> which is a list of tuples in the form <code>reg = &lt;address1 length1 [address2 length2] [address3 length3] ... &gt;</code>.
  Each tuple represents an address range used by the device.  Each 
address value is a list of one or more 32 bit integers called <i>cells</i>.  Similarly, the length value can either be a list of cells, or empty.
</p><p>Since both the address and length fields are variable of variable size, the <code>#address-cells</code> and <code>#size-cells</code>
 properties in the parent node are used to state how many cells are in 
each field.  Or in other words, interpreting a reg property correctly 
requires the parent node's #address-cells and #size-cells values.  To 
see how this all works, lets add the addressing properties to the sample
 device tree, starting with the CPUs.
</p>
<h3><span class="mw-headline" id="CPU_addressing">CPU addressing</span></h3>
<p>The CPU nodes represent the simplest case when talking about 
addressing.  Each CPU is assigned a single unique ID, and there is no 
size associated with CPU ids.
</p><p><br>
</p>
<pre>    cpus {
        <b>#address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;</b>
        cpu@0 {
            compatible = "arm,cortex-a9";
            <b>reg = &lt;0&gt;;</b>
        };
        cpu@1 {
            compatible = "arm,cortex-a9";
            <b>reg = &lt;1&gt;;</b>
        };
    };
</pre>
<p>In the <code>cpus</code> node, <code>#address-cells</code> is set to 1, and <code>#size-cells</code> is set to 0.  This means that child <code>reg</code>
 values are a single uint32 that represent the address with no size 
field.  In this case, the two cpus are assigned addresses 0 and 1.  <code>#size-cells</code> is 0 for cpu nodes because each cpu is only assigned a single address.
</p><p>You'll also notice that the <code>reg</code> value matches the value in the node name.  By convention, if a node has a <code>reg</code> property, then the node name must include the unit-address, which is the first address value in the <code>reg</code> property.
</p>
<h3><span class="mw-headline" id="Memory_Mapped_Devices">Memory Mapped Devices</span></h3>
<p>Instead of single address values like found in the cpu nodes, a 
memory mapped device is assigned a range of addresses that it will 
respond to.  <code>#size-cells</code> is used to state how large the length field is in each child <code>reg</code>
 tuple.  In the following example, each address value is 1 cell (32 
bits), and each length value is also 1 cell, which is typical on 32 bit 
systems.  64 bit machines may use a value of 2 for #address-cells and 
#size-cells to get 64 bit addressing in the device tree.
</p>
<pre>/dts-v1/;

/ {
    <b>#address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;</b>

    ...

    serial@101f0000 {
        compatible = "arm,pl011";
        <b>reg = &lt;0x101f0000 0x1000 &gt;;</b>
    };

    serial@101f2000 {
        compatible = "arm,pl011";
        <b>reg = &lt;0x101f2000 0x1000 &gt;;</b>
    };

    gpio@101f3000 {
        compatible = "arm,pl061";
        <b>reg = &lt;0x101f3000 0x1000
               0x101f4000 0x0010&gt;;</b>
    };

    interrupt-controller@10140000 {
        compatible = "arm,pl190";
        <b>reg = &lt;0x10140000 0x1000 &gt;;</b>
    };

    spi@10115000 {
        compatible = "arm,pl022";
        <b>reg = &lt;0x10115000 0x1000 &gt;;</b>
    };

    ...

};
</pre>
<p>Each device is assigned a base address, and the size of the region it
 is assigned.  The GPIO device address in this example is assigned two 
address ranges; 0x101f3000...0x101f3fff and 0x101f4000..0x101f400f.
</p><p>Some devices live on a bus with a different addressing scheme.  
For example, a device can be attached to an external bus with discrete 
chip select lines.  Since each parent node defines the addressing domain
 for its children, the address mapping can be chosen to best describe 
the system.  The code below show address assignment for devices attached
 to the external bus with the chip select number encoded into the 
address.
</p>
<pre>    external-bus {
        <b>#address-cells = &lt;2&gt;;
        #size-cells = &lt;1&gt;;</b>

        ethernet@0,0 {
            compatible = "smc,smc91c111";
            <b>reg = &lt;0 0 0x1000&gt;;</b>
        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            <b>reg = &lt;1 0 0x1000&gt;;</b>
            rtc@58 {
                compatible = "maxim,ds1338";
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            <b>reg = &lt;2 0 0x4000000&gt;;</b>
        };
    };
</pre>
<p>The <code>external-bus</code> uses 2 cells for the address value; one
 for the chip select number, and one for the offset from the base of the
 chip select.  The length field remains as a single cell since only the 
offset portion of the address needs to have a range.  So, in this 
example, each <code>reg</code> entry contains 3 cells; the chipselect number, the offset, and the length.
</p><p>Since the address domains are contained to a node and its 
children, parent nodes are free to define whatever addressing scheme 
makes sense for the bus.  Nodes outside of the immediate parent and 
child nodes do not normally have to care about the local addressing 
domain, and addresses have to be mapped to get from one domain to 
another.
</p>
<h3><span class="mw-headline" id="Non_Memory_Mapped_Devices">Non Memory Mapped Devices</span></h3>
<p>Other devices are not memory mapped on the processor bus.  They can 
have address ranges, but they are not directly accessible by the CPU.  
Instead the parent device's driver would perform indirect access on 
behalf of the CPU.
</p><p>To take the example of i2c devices, each device is assigned an 
address, but there is no length or range associated with it.  This looks
 much the same as CPU address assignments.
</p>
<pre>        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            <b>#address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;</b>
            reg = &lt;1 0 0x1000&gt;;
            rtc@58 {
                compatible = "maxim,ds1338";
                <b>reg = &lt;58&gt;;</b>
            };
        };
</pre>
<h3><span id="Ranges_(Address_Translation)"></span><span class="mw-headline" id="Ranges_.28Address_Translation.29">Ranges (Address Translation)</span></h3>
<p>We've talked about how to assign addresses to devices, but at this 
point those addresses are only local to the device node.  It doesn't yet
 describe how to map from those address to an address that the CPU can 
use.
</p><p>The root node always describes the CPU's view of the address 
space.  Child nodes of the root are already using the CPU's address 
domain, and so do not need any explicit mapping.  For example, the 
serial@101f0000 device is directly assigned the address 0x101f0000.
</p><p>Nodes that are not direct children of the root do not use the 
CPU's address domain.  In order to get a memory mapped address the 
device tree must specify how to translate addresses from one domain to 
another.  The <code>ranges</code> property is used for this purpose.
</p><p>Here is the sample device tree with the ranges property added.
</p>
<pre>/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    ...
    external-bus {
        #address-cells = &lt;2&gt;
        #size-cells = &lt;1&gt;;
        <b>ranges = &lt;0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
                  2 0  0x30000000   0x1000000&gt;; // Chipselect 3, NOR Flash</b>

        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = &lt;0 0 0x1000&gt;;
        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            reg = &lt;1 0 0x1000&gt;;
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = &lt;58&gt;;
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            reg = &lt;2 0 0x4000000&gt;;
        };
    };
};
</pre>
<p><code>ranges</code> is a list of address translations.  Each entry in
 the ranges table is a tuple containing the child address, the parent 
address, and the size of the region in the child address space.  The 
size of each field is determined by taking the child's <code>#address-cells</code> value, the parent's <code>#address-cells</code> value, and the child's <code>#size-cells</code>
 value.  For the external bus in our example, the child address is 2 
cells, the parent address is 1 cell, and the size is also 1 cell.  Three
 ranges are being translated:
</p>
<ul><li>Offset 0 from chip select 0 is mapped to address range 0x10100000..0x1010ffff</li>
<li>Offset 0 from chip select 1 is mapped to address range 0x10160000..0x1016ffff</li>
<li>Offset 0 from chip select 2 is mapped to address range 0x30000000..0x30ffffff</li></ul>
<p>Alternately, if the parent and child address spaces are identical, then a node can instead add an empty <code>ranges</code>
 property.  The presence of an empty ranges property means addresses in 
the child address space are mapped 1:1 onto the parent address space.
</p><p>You might ask why address translation is used at all when it 
could all be written with 1:1 mapping.  Some busses (like PCI) have 
entirely different address spaces whose details need to be exposed to 
the operating system.  Others have DMA engines which need to know the 
real address on the bus.  Sometimes devices need to be grouped together 
because they all share the same software programmable physical address 
mapping.  Whether or not 1:1 mappings should be used depends a lot on 
the information needed by the Operating system, and on the hardware 
design.
</p><p>You should also notice that there is no <code>ranges</code> 
property in the i2c@1,0 node.  The reason for this is that unlike the 
external bus, devices on the i2c bus are not memory mapped on the CPU's 
address domain.  Instead, the CPU indirectly accesses the rtc@58 device 
via the i2c@1,0 device.  The lack of a <code>ranges</code> property means that a device cannot be directly accessed by any device other than it's parent.
</p>
<h2><span class="mw-headline" id="How_Interrupts_Work">How Interrupts Work</span></h2>
<p>Unlike address range translation which follows the natural structure 
of the tree, Interrupt signals can originate from and terminate on any 
device in a machine.  Unlike device addressing which is naturally 
expressed in the device tree, interrupt signals are expressed as links 
between nodes independent of the tree.  Four properties are used to 
describe interrupt connections:
</p>
<ul><li><code>interrupt-controller</code> - An empty property declaring a node as a device that receives interrupt signals</li>
<li><code>#interrupt-cells</code> - This is a property of the interrupt controller node.  It states how many cells are in an <i>interrupt specifier</i> for this interrupt controller (Similar to <code>#address-cells</code> and <code>#size-cells</code>).</li>
<li><code>interrupt-parent</code> - A property of a device node containing a <i>phandle</i>
 to the interrupt controller that it is attached to.  Nodes that do not 
have an interrupt-parent property can also inherit the property from 
their parent node.</li>
<li><code>interrupts</code> - A property of a device node containing a list of <i>interrupt specifiers</i>, one for each interrupt output signal on the device.</li></ul>
<p>An <i>interrupt specifier</i> is one or more cells of data (as 
specified by #interrupt-cells) that specifies which interrupt input the 
device is attached to.  Most devices only have a single interrupt output
 as shown in the example below, but it is possible to have multiple 
interrupt outputs on a device.  The meaning of an interrupt specifier 
depends entirely on the binding for the interrupt controller device.  
Each interrupt controller can decide how many cells it need to uniquely 
define an interrupt input.
</p><p>The following code adds interrupt connections to our Coyote's Revenge example machine:
</p>
<pre>/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    <b>interrupt-parent = &lt;&amp;intc&gt;;</b>

    cpus {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        cpu@0 {
            compatible = "arm,cortex-a9";
            reg = &lt;0&gt;;
        };
        cpu@1 {
            compatible = "arm,cortex-a9";
            reg = &lt;1&gt;;
        };
    };

    serial@101f0000 {
        compatible = "arm,pl011";
        reg = &lt;0x101f0000 0x1000 &gt;;
        <b>interrupts = &lt; 1 0 &gt;;</b>
    };

    serial@101f2000 {
        compatible = "arm,pl011";
        reg = &lt;0x101f2000 0x1000 &gt;;
        <b>interrupts = &lt; 2 0 &gt;;</b>
    };

    gpio@101f3000 {
        compatible = "arm,pl061";
        reg = &lt;0x101f3000 0x1000
               0x101f4000 0x0010&gt;;
        <b>interrupts = &lt; 3 0 &gt;;</b>
    };

    <b>intc:</b> interrupt-controller@10140000 {
        compatible = "arm,pl190";
        reg = &lt;0x10140000 0x1000 &gt;;
        <b>interrupt-controller;
        #interrupt-cells = &lt;2&gt;;</b>
    };

    spi@10115000 {
        compatible = "arm,pl022";
        reg = &lt;0x10115000 0x1000 &gt;;
        <b>interrupts = &lt; 4 0 &gt;;</b>
    };

    external-bus {
        #address-cells = &lt;2&gt;
        #size-cells = &lt;1&gt;;
        ranges = &lt;0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
                  2 0  0x30000000   0x1000000&gt;; // Chipselect 3, NOR Flash

        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = &lt;0 0 0x1000&gt;;
            <b>interrupts = &lt; 5 2 &gt;;</b>
        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            reg = &lt;1 0 0x1000&gt;;
            <b>interrupts = &lt; 6 2 &gt;;</b>
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = &lt;58&gt;;
                <b>interrupts = &lt; 7 3 &gt;;</b>
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            reg = &lt;2 0 0x4000000&gt;;
        };
    };
};
</pre>
<p>Some things to notice:
</p>
<ul><li>The machine has a single interrupt controller, interrupt-controller@10140000.</li>
<li>The label 'intc:' has been added to the interrupt controller node, 
and the label was used to assign a phandle to the interrupt-parent 
property in the root node.  This interrupt-parent value becomes the 
default for the system because all child nodes inherit it unless it is 
explicitly overridden.</li>
<li>Each device uses an interrupt property to specify a different interrupt input line.</li>
<li>#interrupt-cells is 2, so each interrupt specifier has 2 cells.  
This example uses the common pattern of using the first cell to encode 
the interrupt line number, and the second cell to encode flags such as 
active high vs. active low, or edge vs. level sensitive.  For any given 
interrupt controller, refer to the controller's binding documentation to
 learn how the specifier is encoded.</li></ul>
<h2><span class="mw-headline" id="Device_Specific_Data">Device Specific Data</span></h2>
<p>Beyond the common properties, arbitrary properties and child nodes 
can be added to nodes.  Any data needed by the operating system can be 
added as long as some rules are followed.
</p><p>First, new device-specific property names should use a 
manufacture prefix so that they don't conflict with existing standard 
property names.
</p><p>Second, the meaning of the properties and child nodes must be 
documented in a binding so that a device driver author knows how to 
interpret the data.  A binding documents what a particular compatible 
value means, what properties it should have, what child nodes it might 
have, and what device it represents.  Each unique <code>compatible</code>
 value should have its own binding (or claim compatibility with another 
compatible value).  Bindings for new devices are documented in this 
wiki.  See the <a href="https://elinux.org/Main_Page" title="Main Page">Main Page</a> for a description of the documentation format and review process.
</p><p>Third, post new bindings for review on the 
devicetree-discuss@lists.ozlabs.org mailing list.  Reviewing new 
bindings catches a lot of common mistakes that will cause problems in 
the future.
</p>
<h2><span class="mw-headline" id="Special_Nodes">Special Nodes</span></h2>
<h3><span class="mw-headline" id="aliases_Node"><code>aliases</code> Node</span></h3>
<p>A specific node is normally referenced by the full path, like <code>/external-bus/ethernet@0,0</code>, but that gets cumbersome when what a user really wants to know is, "which device is eth0?"  The <code>aliases</code> node can be used to assign a short <i>alias</i> to a full device path.  For example:
</p>
<pre>    aliases {
        ethernet0 = &amp;eth0;
        serial0 = &amp;serial0;
    };
</pre>
<p>The operating system is welcome to use the aliases when assigning an identifier to a device.
</p><p>You'll notice a new syntax used here.  The <code><i>property</i> = &amp;<i>label</i>;</code> syntax assigns the full node path referenced by the label as a string property.  This is different from the <code><i>phandle</i> = &lt; &amp;<i>label</i> &gt;;</code> form used earlier which inserts a phandle value into a cell.
</p>
<h3><span class="mw-headline" id="chosen_Node"><code>chosen</code> Node</span></h3>
<p>The <code>chosen</code> node doesn't represent a real device, but 
serves as a place for passing data between firmware and the operating 
system, like boot arguments.  Data in the chosen node does not represent
 the hardware.  Typically the chosen node is left empty in .dts source 
files and populated at boot time.
</p><p>In our example system, firmware might add the following to the chosen node:
</p>
<pre>    chosen {
        bootargs = "root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200";
    };
</pre>
<h2><span class="mw-headline" id="Advanced_Topics">Advanced Topics</span></h2>
<h3><span class="mw-headline" id="Advanced_Sample_Machine">Advanced Sample Machine</span></h3>
<p>Now that we've got the basics defined, let's add some hardware to the
 sample machine to discuss some of the more complicated use cases.
</p><p>The advanced sample machine adds a PCI host bridge with control 
registers memory mapped to 0x10180000, and BARs programmed to start 
above the address 0x80000000.
</p><p>Given what we already know about the device tree, we can start 
with the addition of the following node to describe the PCI host bridge.
</p>
<pre>        <b>pci@10180000 {
            compatible = "arm,versatile-pci-hostbridge", "pci";
            reg = &lt;0x10180000 0x1000&gt;;
            interrupts = &lt;8 0&gt;;
        };</b>
</pre>
<h3><span class="mw-headline" id="PCI_Host_Bridge">PCI Host Bridge</span></h3>
<p>This section describes the Host/PCI bridge node.
</p><p>Note, some basic knowledge of PCI is assumed in this section. 
This is NOT a tutorial about PCI, if you need some more in depth 
information, please read<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup>. You can also refer to either
<a rel="nofollow" class="external text" href="https://www.power.org/documentation/power-org-standard-for-embedded-power-architecture-platform-requirements-epapr-v1-1-2/">ePAPR v1.1</a>
or the <a rel="nofollow" class="external text" href="https://www.openfirmware.info/data/docs/bus.pci.pdf">PCI Bus Binding to Open Firmware</a>. A complete working example for a Freescale MPC5200 can be found <a href="https://elinux.org/index.php?title=MPC5200:PCI&amp;action=edit&amp;redlink=1" class="new" title="MPC5200:PCI (page does not exist)">here</a>.
</p>
<h4><span class="mw-headline" id="PCI_Bus_numbering">PCI Bus numbering</span></h4>
<p>Each PCI bus segment is uniquely numbered, and the bus numbering is exposed in the pci node by using the <code>bus-range</code>
 property, which contains two cells.  The first cell gives the bus 
number assigned to this node, and the second cell gives the maximum bus 
number of any of the subordinate PCI busses.
</p><p>The sample machine has a single pci bus, so both cells are 0.
</p>
<pre>        pci@0x10180000 {
            compatible = "arm,versatile-pci-hostbridge", "pci";
            reg = &lt;0x10180000 0x1000&gt;;
            interrupts = &lt;8 0&gt;;
            <b>bus-range = &lt;0 0&gt;;</b>
        };
</pre>
<h4><span class="mw-headline" id="PCI_Address_Translation">PCI Address Translation</span></h4>
<p>Similar to the local bus described earlier, the PCI address space is 
completely separate from the CPU address space, so address translation 
is needed to get from a PCI address to a CPU address. As always, this is
 done using the <a href="#Ranges_.28Address_Translation.29"><code>range</code></a>, <code>#address-cells</code>, and <code>#size-cells</code> properties.
</p>
<pre>        pci@0x10180000 {
            compatible = "arm,versatile-pci-hostbridge", "pci";
            reg = &lt;0x10180000 0x1000&gt;;
            interrupts = &lt;8 0&gt;;
            bus-range = &lt;0 0&gt;;

            <b>#address-cells = &lt;3&gt;
            #size-cells = &lt;2&gt;;
            ranges = &lt;<span style="color:red">0x42000000 0 0x80000000</span> <span style="color:blue">0x80000000</span> <span style="color:olive">0 0x20000000</span>
                      <span style="color:red">0x02000000 0 0xa0000000</span> <span style="color:blue">0xa0000000</span> <span style="color:olive">0 0x10000000</span>
                      <span style="color:red">0x01000000 0 0x00000000</span> <span style="color:blue">0xb0000000</span> <span style="color:olive">0 0x01000000</span>&gt;;</b>
        };
</pre>
<p>As you can see, <span style="color:red">child addresses</span> (PCI 
addresses) use 3 cells, and PCI ranges are encoded into 2 cells. The 
first question might be, why do we need three 32 bit cells to specify a 
PCI address. The three cells are labeled phys.hi, phys.mid and phys.low <sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[2]</a></sup>.
</p>
<ul><li><code>phys.hi cell:  npt000ss bbbbbbbb dddddfff rrrrrrrr</code></li>
<li><code>phys.mid cell: hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh</code></li>
<li><code>phys.low cell: llllllll llllllll llllllll llllllll</code></li></ul>
<p>PCI addresses are 64 bits wide, and are encoded into phys.mid and 
phys.low.  However, the really interesting things are in phys.high which
 is a bit field:
</p>
<ul><li><code>n</code>: relocatable region flag (doesn't play a role here)</li>
<li><code>p</code>: prefetchable (cacheable) region flag</li>
<li><code>t</code>: aliased address flag (doesn't play a role here)</li>
<li><code>ss</code>: space code
<ul><li>00: configuration space</li>
<li>01: I/O space</li>
<li>10: 32 bit memory space</li>
<li>11: 64 bit memory space</li></ul></li>
<li><code>bbbbbbbb</code>: The PCI bus number. PCI may be structured hierarchically. So we may have PCI/PCI bridges which will define sub busses.</li>
<li><code>ddddd</code>: The device number, typically associated with IDSEL signal connections.</li>
<li><code>fff</code>: The function number. Used for multifunction PCI devices.</li>
<li><code>rrrrrrrr</code>: Register number; used for configuration cycles.</li></ul>
<p>For the purpose of PCI address translation, the important fields are <code>p</code> and <code>ss</code>.
  The value of p and ss in phys.hi determines which PCI address space is
 being accessed.  So looking onto our ranges property, we have three 
regions:
</p>
<ul><li>a 32 bit prefetchable memory region beginning on PCI address 
0x80000000 of 512 MByte size which will be mapped onto address 
0x80000000 on the host CPU.</li>
<li>a 32 bit non-prefetchable memory region beginning on PCI address 
0xa0000000 of 256 MByte size which will be mapped onto address 
0xa0000000 on the host CPU.</li>
<li>an I/O region beginning on PCI address 0x00000000 of 16 MByte size which will be mapped onto address 0xb0000000 on the host CPU.</li></ul>
<p>To throw a wrench into the works, the presence of the phys.hi 
bitfield means that an operating system needs to know that the node 
represents a PCI bridge so that it can ignore the irrelevant fields for 
the purpose of translation.  An OS will look for the string "pci" in the
 PCI bus nodes to determine whether it needs to mask of the extra 
fields.
</p>
<h4><span class="mw-headline" id="PCI_DMA_Address_Translation">PCI DMA Address Translation</span></h4>
<p>The above ranges define how the CPU see the PCI memory, and helps the
 CPU to set up the right memory windows and write the right parameters 
into various PCI device registers. This is sometimes referred to as <i>outbound memory</i>.
</p><p>A special case of address translation concerns how the PCI host 
hardware sees the core memory of the system. This happens when the PCI 
host controller will act as master and independently access the core 
memory of the system. As this is often a different view than that of the
 CPU (due to how the memory lines have been wired) this may need to be 
programmed into the PCI host controller on initialization. This is seen 
as a kind of DMA as the PCI bus independently performs direct memory 
access, and for this reason the mappings are named <b>dma-ranges</b>. This type of memory mapping is sometimes referred to as <i>inbound memory</i> and is not part of the PCI device tree specification.
</p><p>In some cases, a ROM (BIOS) or similar will set up these 
registers on boot, but in other cases, the PCI controller is completely 
uninitialized and these translations need to be set up from the device 
tree. The PCI host driver will then typically parse the dma-ranges 
property and set up some registers in the host controller accordingly.
</p><p>Expanding on the example above:
</p>
<pre>        pci@0x10180000 {
            compatible = "arm,versatile-pci-hostbridge", "pci";
            reg = &lt;0x10180000 0x1000&gt;;
            interrupts = &lt;8 0&gt;;
            bus-range = &lt;0 0&gt;;

            #address-cells = &lt;3&gt;
            #size-cells = &lt;2&gt;;
            ranges = &lt;0x42000000 0 0x80000000 0x80000000 0 0x20000000
                      0x02000000 0 0xa0000000 0xa0000000 0 0x10000000
                      0x01000000 0 0x00000000 0xb0000000 0 0x01000000
            <b>dma-ranges = &lt;<span style="color:red">0x02000000 0 0x00000000</span> <span style="color:blue">0x80000000</span> <span style="color:olive">0 0x20000000</span>&gt;;</b>
        };
</pre>
<p>This <b>dma-ranges</b> entry indicates that from the PCI host controller's point of view, the <span style="color:olive">512 MB</span> at PCI address <span style="color:red">0x00000000</span> will appear in the main core memory at address <span style="color:blue">0x80000000</span>. As you can see we just set the <i>ss</i> address type to 0x02 indicating this is some 32bit memory.
</p>
<h3><span class="mw-headline" id="Advanced_Interrupt_Mapping">Advanced Interrupt Mapping</span></h3>
<p>Now we come to the most interesting part, PCI interrupt mapping. A 
PCI device can trigger interrupts using the wires #INTA, #INTB, #INTC 
and #INTD. The # hash sign in front of the interrupt names means it is 
active low, this is a common convention, and PCI interrupt lines are 
always active low. A single-function device is obligated to use #INTA 
for interrupts.  A multi-function device must use #INTA if it uses a 
single interrupt pin, #INTA and #INTB if it uses two interrupt pins, 
etc.  Due to these rules, #INTA is normally used by more functions than 
#INTB, #INTC, and #INTD.  To distribute the load across the four IRQ 
lines backing #INTA through #INTD, each PCI slot or device is typically 
wired to different inputs on the interrupt controller in rotating manner
 so as to avoid having all #INTA clients connected to the same incoming 
interrupt line.  This procedure is referred to as <i>swizzling</i> the 
interrupts.  So, the device tree needs a way of mapping each PCI 
interrupt signal to the inputs of the interrupt controller.  The <code>#interrupt-cells</code>, <code>interrupt-map</code> and <code>interrupt-map-mask</code> properties are used to describe the interrupt mapping.
</p><p>Actually, the interrupt mapping described here isn't limited to 
PCI busses, any node can specify complex interrupt maps, but the PCI 
case is by far the most common.
</p>
<pre>        pci@0x10180000 {
            compatible = "arm,versatile-pci-hostbridge", "pci";
            reg = &lt;0x10180000 0x1000&gt;;
            interrupts = &lt;8 0&gt;;
            bus-range = &lt;0 0&gt;;

            #address-cells = &lt;3&gt;
            #size-cells = &lt;2&gt;;
            ranges = &lt;0x42000000 0 0x80000000  0x80000000  0 0x20000000
                      0x02000000 0 0xa0000000  0xa0000000  0 0x10000000
                      0x01000000 0 0x00000000  0xb0000000  0 0x01000000&gt;;

            <b>#interrupt-cells = &lt;1&gt;;
            interrupt-map-mask = &lt;0xf800 0 0 7&gt;;
            interrupt-map = &lt;<span style="color:fuchsia">0xc000 0 0 1</span> <span style="color:green">&amp;intc</span> <span style="color:maroon"> 9 3</span> // 1st slot
                             <span style="color:fuchsia">0xc000 0 0 2</span> <span style="color:green">&amp;intc</span> <span style="color:maroon">10 3</span>
                             <span style="color:fuchsia">0xc000 0 0 3</span> <span style="color:green">&amp;intc</span> <span style="color:maroon">11 3</span>
                             <span style="color:fuchsia">0xc000 0 0 4</span> <span style="color:green">&amp;intc</span> <span style="color:maroon">12 3</span>

                             <span style="color:fuchsia">0xc800 0 0 1</span> <span style="color:green">&amp;intc</span> <span style="color:maroon">10 3</span> // 2nd slot
                             <span style="color:fuchsia">0xc800 0 0 2</span> <span style="color:green">&amp;intc</span> <span style="color:maroon">11 3</span>
                             <span style="color:fuchsia">0xc800 0 0 3</span> <span style="color:green">&amp;intc</span> <span style="color:maroon">12 3</span>
                             <span style="color:fuchsia">0xc800 0 0 4</span> <span style="color:green">&amp;intc</span> <span style="color:maroon"> 9 3</span>&gt;;</b>
        };
</pre>
<p><br>
</p><p>First you'll notice that PCI interrupt numbers use only one cell,
 unlike the system interrupt controller which uses 2 cells; one for the 
irq number, and one for flags.  PCI only needs one cell for interrupts 
because PCI interrupts are specified to always be level-low sensitive.
</p><p>In our example board, we have 2 PCI slots with 4 interrupt lines,
 respectively, so we have to map 8 interrupt lines to the interrupt 
controller. This is done using the interrupt-map property. The exact 
procedure for interrupt mapping is described in<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup> .
</p><p>Because the interrupt number (#INTA etc.) is not sufficient to 
distinguish between several PCI devices on a single PCI bus, we also 
have to denote which PCI device triggered the interrupt line. 
Fortunately, every PCI device has a unique device number that we can use
 for. To distinguish between interrupts of several PCI devices we need a
 tuple consisting of the PCI device number and the PCI interrupt number.
 Speaking more generally, we construct a <span style="color:fuchsia">unit interrupt specifier</span> which has four cells:
</p>
<ul><li>three <span style="color:red">#address-cells</span> consisting of phys.hi, phys.mid, phys.low, and</li>
<li>one #interrupt-cell (#INTA, #INTB, #INTC, #INTD).</li></ul>
<p>Because we only need the device number part of the PCI address, the 
interrupt-map-mask property comes into play. interrupt-map-mask is also a
 4-tuple like the <span style="color:fuchsia">unit interrupt specifier</span>. The 1's in the mask denote which part of the <span style="color:fuchsia">unit interrupt specifier</span>
 should be taken into account. In our example we can see that only the 
device number part of phys.hi is required and we need 3 bits to 
distinguish between the four interrupt lines (Counting PCI interrupt 
lines start at 1, not at 0!).
</p><p>Now we can construct the interrupt-map property. This property is
 a table and each entry in this table consists of a child (PCI bus) <span style="color:fuchsia">unit interrupt specifier</span>, a <span style="color:green">parent handle</span> (the interrupt controller which is responsible for serving the interrupts) and a <span style="color:maroon">parent unit interrupt specifier</span>.
 So in the first line we can read that the PCI interrupt #INTA is mapped
 onto IRQ 9, level low sensitive of our interrupt controller.  <sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup>.
</p><p>The only missing part for now are the weird numbers int the PCI bus <span style="color:fuchsia">unit interrupt specifier</span>.
  The important part of the unit interrupt specifier is the device 
number from the phys.hi bit field.  Device number is board specific, and
 it depends on how each PCI host controller activates the IDSEL pin on 
each device.  In this example, PCI slot 1 is assigned device id 24 
(0x18), and PCI slot 2 is assigned device id 25 (0x19).  The value of 
phys.hi for each slot is determined by shifting the device number up by 
11 bits into the ddddd section of the bitfield as follows:
</p>
<ul><li>phys.hi for slot 1 is 0xC000, and</li>
<li>phys.hi for slot 2 is 0xC800.</li></ul>
<p>Putting it all together the interrupt-map property show:
</p>
<ul><li>#INTA of slot 1 is IRQ9, level low sensitive on the primary interrupt controller</li>
<li>#INTB of slot 1 is IRQ10, level low sensitive on the primary interrupt controller</li>
<li>#INTC of slot 1 is IRQ11, level low sensitive on the primary interrupt controller</li>
<li>#INTD of slot 1 is IRQ12, level low sensitive on the primary interrupt controller</li></ul>
<p>and
</p>
<ul><li>#INTA of slot 2 is IRQ10, level low sensitive on the primary interrupt controller</li>
<li>#INTB of slot 2 is IRQ11, level low sensitive on the primary interrupt controller</li>
<li>#INTC of slot 2 is IRQ12, level low sensitive on the primary interrupt controller</li>
<li>#INTD of slot 2 is IRQ9, level low sensitive on the primary interrupt controller</li></ul>
<p>The <code>interrupts = &lt;8 0&gt;;</code> property describes the 
interrupts the host/PCI-bridge controller itself may trigger. Don't mix 
up these interrupts with interrupts <i>PCI devices</i> might trigger (using INTA, INTB, ...).
</p><p>One final thing to note.  Just like with the interrupt-parent 
property, the presence of an interrupt-map property on a node will 
change the default interrupt controller for all child and grandchild 
nodes.  In this PCI example, that means that the PCI host bridge becomes
 the default interrupt controller.  If a device attached via the PCI bus
 has a direct connection to another interrupt controller, then it also 
needs to specify its own interrupt-parent property.
</p>
<h2><span class="mw-headline" id="Notes">Notes</span></h2>
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite_ref-1"><span class="cite-accessibility-label">Jump up </span>↑</a></span> <span class="reference-text">Tom Shanley / Don Anderson: PCI System Architecture. <a rel="nofollow" class="external text" href="http://www.mindshare.com/">Mindshare Inc.</a></span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><a href="#cite_ref-2"><span class="cite-accessibility-label">Jump up </span>↑</a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://playground.sun.com/1275/bindings/pci/pci2_1.pdf">PCI Bus Bindings to Open Firmware.</a></span>
</li>
<li id="cite_note-3"><span class="mw-cite-backlink"><a href="#cite_ref-3"><span class="cite-accessibility-label">Jump up </span>↑</a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://playground.sun.com/1275/practice/imap/imap0_9d.pdf">Open Firmware Recommended Practice: Interrupt Mapping</a></span>
</li>
<li id="cite_note-4"><span class="mw-cite-backlink"><a href="#cite_ref-4"><span class="cite-accessibility-label">Jump up </span>↑</a></span> <span class="reference-text">PCI interrupts are always level low sensitive.</span>
</li>
</ol></div>

<!-- 
NewPP limit report
Cached time: 20191229110409
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.074 seconds
Real time usage: 0.091 seconds
Preprocessor visited node count: 226/1000000
Preprocessor generated node count: 382/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 2043/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key elinux:pcache:idhash:106826-0!canonical and timestamp 20191229110408 and revision id 503926
 -->
</div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://elinux.org/index.php?title=Device_Tree_Usage&amp;oldid=503926">https://elinux.org/index.php?title=Device_Tree_Usage&amp;oldid=503926</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://elinux.org/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://elinux.org/Category:Device_tree" title="Category:Device tree">Device tree</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://elinux.org/index.php?title=Special:UserLogin&amp;returnto=Device+Tree+Usage" title="You are encouraged to log in; however, it is not mandatory [Alt+Shift+o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="https://elinux.org/Special:RequestAccount" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="https://elinux.org/Device_Tree_Usage" title="View the content page [Alt+Shift+c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://elinux.org/index.php?title=Talk:Device_Tree_Usage&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [Alt+Shift+t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label">
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="https://elinux.org/Device_Tree_Usage">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://elinux.org/index.php?title=Device_Tree_Usage&amp;action=edit" title="This page is protected.
You can view its source [Alt+Shift+e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://elinux.org/index.php?title=Device_Tree_Usage&amp;action=history" title="Past revisions of this page [Alt+Shift+h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label" style="">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search eLinux.org" title="Search eLinux.org [Alt+Shift+f]" accesskey="f" id="searchInput" tabindex="1" autocomplete="off"><input type="hidden" value="Special:Search" name="title"><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="https://elinux.org/Main_Page" title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-Navigation" aria-labelledby="p-Navigation-label">
			<h3 id="p-Navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="https://elinux.org/Main_Page" title="Visit the main page [Alt+Shift+z]" accesskey="z">Main Page</a></li><li id="n-portal"><a href="https://elinux.org/eLinux.org:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li><li id="n-currentevents"><a href="https://elinux.org/eLinux.org:Current_events" title="Find background information on current events">Current events</a></li><li id="n-recentchanges"><a href="https://elinux.org/Special:RecentChanges" title="A list of recent changes in the wiki [Alt+Shift+r]" accesskey="r">Recent changes</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li><li id="n-Volunteering"><a href="https://elinux.org/Sitesupport-url">Volunteering</a></li><li id="n-Bug-Tracker"><a href="http://bugs.elinux.org/" rel="nofollow">Bug Tracker</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-Where_else_to_find_us" aria-labelledby="p-Where_else_to_find_us-label">
			<h3 id="p-Where_else_to_find_us-label">Where else to find us</h3>
			<div class="body">
								<ul>
					<li id="n-Google.2B-Community"><a href="https://plus.google.com/u/0/communities/113852495250648539361" rel="nofollow">Google+ Community</a></li><li id="n-Twitter-.28.40elinux.29"><a href="https://twitter.com/elinux" rel="nofollow">Twitter (@elinux)</a></li><li id="n-.23elinux-on-Freenode"><a href="irc://#elinux@irc.freenode.net" rel="nofollow">#elinux on Freenode</a></li><li id="n-Facebook-.28.40elinux.org.29"><a href="https://www.facebook.com/elinuxorg-750739005020534/" rel="nofollow">Facebook (@elinux.org)</a></li><li id="n-Mailing-Lists"><a href="http://www.elinux.org/ELinuxWiki:Mailing_List" rel="nofollow">Mailing Lists</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Tools</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="https://elinux.org/Special:WhatLinksHere/Device_Tree_Usage" title="A list of all wiki pages that link here [Alt+Shift+j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="https://elinux.org/Special:RecentChangesLinked/Device_Tree_Usage" rel="nofollow" title="Recent changes in pages linked from this page [Alt+Shift+k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="https://elinux.org/Special:SpecialPages" title="A list of all special pages [Alt+Shift+q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://elinux.org/index.php?title=Device_Tree_Usage&amp;printable=yes" rel="alternate" title="Printable version of this page [Alt+Shift+p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://elinux.org/index.php?title=Device_Tree_Usage&amp;oldid=503926" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://elinux.org/index.php?title=Device_Tree_Usage&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 12 November 2019, at 11:35.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="https://creativecommons.org/licenses/by-sa/3.0/">a Creative Commons Attribution-ShareAlike 3.0 Unported License</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="https://elinux.org/eLinux.org:Privacy_policy" title="eLinux.org:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="https://elinux.org/eLinux.org:About" title="eLinux.org:About">About eLinux.org</a></li>
								<li id="footer-places-disclaimer"><a href="https://elinux.org/eLinux.org:General_disclaimer" title="eLinux.org:General disclaimer">Disclaimers</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="https://creativecommons.org/licenses/by-sa/3.0/"><img src="Device%20Tree%20Usage%20-%20eLinux.org_files/88x31.png" alt="a Creative Commons Attribution-ShareAlike 3.0 Unported License" width="88" height="31"></a>					</li>
										<li id="footer-poweredbyico">
						<a href="https://www.mediawiki.org/"><img src="Device%20Tree%20Usage%20-%20eLinux.org_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.074","walltime":"0.091","ppvisitednodes":{"value":226,"limit":1000000},"ppgeneratednodes":{"value":382,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":2043,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20191229110409","ttl":86400,"transientcontent":false}}});});</script><!-- No web analytics configured. -->
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":203});});</script>
	

<div id="sCLExtInstalled" data-version="5.6" style="display: none;">1</div><div style="display: none; font-size: 13px;" class="suggestions"><div class="suggestions-results"></div><div class="suggestions-special"></div></div></body></html>